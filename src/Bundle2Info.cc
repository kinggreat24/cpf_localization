/*===========================================================================*\
 *                                                                           *
 *                            ACG Localizer                                  *
 *      Copyright (C) 2011 by Computer Graphics Group, RWTH Aachen           *
 *                           www.rwth-graphics.de                            *
 *                                                                           *
 *---------------------------------------------------------------------------*
 *  This file is part of ACG Localizer                                       *
 *                                                                           *
 *  ACG Localizer is free software: you can redistribute it and/or modify    *
 *  it under the terms of the GNU General Public License as published by     *
 *  the Free Software Foundation, either version 3 of the License, or        *
 *  (at your option) any later version.                                      *
 *                                                                           *
 *  ACG Localizer is distributed in the hope that it will be useful,         *
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *
 *  GNU General Public License for more details.                             *
 *                                                                           *
 *  You should have received a copy of the GNU General Public License        *
 *  along with ACG Localizer.  If not, see <http://www.gnu.org/licenses/>.   *
 *                                                                           *
\*===========================================================================*/

#include <vector>
#include <set>
#include <iostream>
#include <fstream>
#include <stdint.h>
#include <string>
#include <cmath>
#include <algorithm>
#include <climits>
#include <sstream>

#include "sfm/parse_bundler.hh"

int main (int argc, char **argv)
{
  /*if( argc != 6 )
  {
    std::cout << "_______________________________________________________________________________________________________" << std::endl;
    std::cout << " -                                                                                                   - " << std::endl;
    std::cout << " -    Bundle2Info - Extract camera and feature information from Bundler output files, save feature   - " << std::endl;
  std::cout << " -                  information (including descriptors) in binary file.                              - " << std::endl;
    std::cout << " -                               2011 by Torsten Sattler (tsattler@cs.rwth-aachen.de)                - " << std::endl;
    std::cout << " -                                                                                                   - " << std::endl;
    std::cout << " - usage: Bundle2Info bundler_output image_list outfile                                              - " << std::endl;
    std::cout << " - Parameters:                                                                                       - " << std::endl;
    std::cout << " -  bundler_output                                                                                   - " << std::endl;
    std::cout << " -     Filename of an output file (usually called bundle.out) generated by Bundler.                  - " << std::endl;
    std::cout << " -                                                                                                   - " << std::endl;
    std::cout << " -  image_list                                                                                       - " << std::endl;
    std::cout << " -     Text file containing the list of images (and their paths relative to the list file)           - " << std::endl;
    std::cout << " -     used by Bundler (usually called list.txt). Notice that the program will try to load the       - " << std::endl;
  std::cout << " -     .key files containing the SIFT-features by simply changing the ending of the image names      - " << std::endl;
  std::cout << " -     from .jpg to .key, using the filenames specified in the list to load the files.               - " << std::endl;
    std::cout << " -                                                                                                   - " << std::endl;
    std::cout << " -  outfile                                                                                          - " << std::endl;
    std::cout << " -     The output generated by Bundle2Info. It is a binary file of the following structure:          - " << std::endl;
    std::cout << " -     number of cameras (uint32_t)                                                                  - " << std::endl;
    std::cout << " -     number of points (uint32_t)                                                                   - " << std::endl;
    std::cout << " -     for every point:                                                                              - " << std::endl;
    std::cout << " -     3D coordinates (float) number of images this point is visible in (uint32_t)                   - " << std::endl;
    std::cout << " -     for every such image: camera id (uint32_t) 2D coordinates scale orientation (floats)          - " << std::endl;
    std::cout << " -     descriptor (unsigned char)                                                                    - " << std::endl;
    std::cout << " -                                                                                                   - " << std::endl;
    std::cout << "_______________________________________________________________________________________________________" << std::endl;
    return 1;
  }*/

  ////
  // get the data from bundler

  std::cout << "-> parsing bundler data " << std::endl;
  //for not aachen

  // parse_bundler parser;
  // if ( !parser.parse_data( argv[1], argv[2] ) )
  // {
  //   std::cerr << "ERROR: could not parse the information from bundler " << std::endl;
  //   return 1;
  // }
  //for aachen
  parse_bundler parser;
  if ( !parser.load_from_binary( argv[1], atoi(argv[2]) ) )
  {
    std::cerr << "ERROR: could not parse the information from bundler " << std::endl;
    return 1;
  }

  // // get the parsed information
  // std::vector< feature_3D_info >& feature_infos_pre = parser1.get_feature_infos();

  // parse_bundler parser;
  // if( !parser.parse_data_from_binary( argv[4], feature_infos_pre, argv[5] ))
  // {
  //   std::cerr << "ERROR: could not parse the information from bundler " << std::endl;
  //   return 1;
  // }



  // get the parsed information
  std::vector< feature_3D_info >& feature_infos = parser.get_feature_infos();
  std::vector< bundler_camera >& camera_infos = parser.get_cameras();


  //transfer to root sift
  for (int i =  0; i < feature_infos.size(); i++) {
    for (int j = 0; j < feature_infos[i].view_list.size(); j++) {
      float L2_norm = 0.0f;
      for (int k = 0; k < 128; k++) {
        L2_norm += float(feature_infos[i].descriptors[128 * j + k]) *
                   float(feature_infos[i].descriptors[128 * j + k]);
      }
      //L2 Normalize

      std::vector<float> temp1;
      for (int k = 0; k < 128; k++) {
        temp1.push_back(feature_infos[i].descriptors[128 * j + k] / std::sqrt(L2_norm));
      }

      float L1_norm = 0;
      for (int k = 0; k < 128; k++) {
        L1_norm += temp1[k];
      }

      for (int k = 0; k < 128; k++) {
        float result = std::sqrt(temp1[k] / L1_norm);
        result =  result * 512.0 + 0.5;
        if (result > 255.0) result = 255.0;

        int tmp_desc = static_cast<uint8_t>(result);
        feature_infos[i].descriptors[128 * j + k] = (unsigned char) tmp_desc;
      }
    }

  }

// std::ofstream ofs_details( "sf_rsift_1.txt", std::ios::out );

  // int nb_desc = 0;
  // for (int i = 0; i < feature_infos.size(); i++)
  // {
  //   if (i % 5 == 0) {
  //     for (int k = 0; k < 128; k++)
  //     {
  //       if (k != 127)
  //       {
  //         ofs_details << (float)feature_infos[i].descriptors[k] << ",";
  //       }
  //       else
  //       {
  //         ofs_details << (float)feature_infos[i].descriptors[k] << std::endl;
  //       }
  //     }
  //     nb_desc++;
  //     //std::cout << " feature " << i << std::endl;
  //   }
  //   if(nb_desc % 10000 == 0)
  //     std::cout << nb_desc << "/10000000" << std::endl;
  //   if(nb_desc == 10000000)
  //     break;
  // }
  // std::cout << nb_desc << std::endl;
  // ofs_details.close();

// return 0;
  uint32_t nb_cameras = parser.get_number_of_cameras();
  uint32_t nb_points = parser.get_number_of_points();
  std::cout << "--> done parsing the bundler output " << std::endl;

  /////
  // do some statistics:
  // average number of features per camera
  // average number of cameras a 3D point is visible in
  std::vector< uint32_t > nb_features_per_cam( nb_cameras, 0 );

  double average_cams_per_feature = 0.0;
  uint32_t max_cams_per_feature = 0.0;

  for ( uint32_t i = 0; i < nb_points; ++i )
  {
    for ( uint32_t j = 0; j < (uint32_t) feature_infos[i].view_list.size(); ++j )
      nb_features_per_cam[feature_infos[i].view_list[j].camera] += 1;

    average_cams_per_feature += (double) feature_infos[i].view_list.size();
    max_cams_per_feature = (max_cams_per_feature > (feature_infos[i].view_list.size())) ? max_cams_per_feature : (feature_infos[i].view_list.size());

  }

  average_cams_per_feature /= double(nb_points);

  double average_features_per_cams = 0.0;
  uint32_t max_features_per_cam = 0;
  uint32_t min_features_per_cam = UINT_MAX;

  for ( uint32_t i = 0; i < nb_cameras; ++i )
  {
    average_features_per_cams += double(nb_features_per_cam[i]);
    max_features_per_cam = (max_features_per_cam > nb_features_per_cam[i] ) ? max_features_per_cam : nb_features_per_cam[i];
    min_features_per_cam = (min_features_per_cam < nb_features_per_cam[i] ) ? min_features_per_cam : nb_features_per_cam[i];
  }
  average_features_per_cams /= double(nb_cameras);

  std::cout << std::endl << "############# Statistics #############" << std::endl;
  std::cout << " # 3D points " << nb_points << ", # cameras " << nb_cameras << std::endl;
  std::cout << " a single 3D point is on average visible in " << average_cams_per_feature << " cameras ( max: " << max_cams_per_feature << " ) " << std::endl;
  std::cout << " min #points in image " << min_features_per_cam << ", average: " << average_features_per_cams << ", max: " << max_features_per_cam << std::endl;
  std::cout << "######################################" << std::endl << std::endl;

  ////
  // save all data
  std::cout << "->saving the information from bundler to " << argv[3] << std::endl;

  std::ofstream ofs( argv[3], std::ios::out | std::ios::binary );

  if ( !ofs.is_open() )
  {
    std::cerr << " Could not write information " << argv[3] << std::endl;
    return 1;
  }

  // write out the number of cameras and points
  std::cout << "write cameras " << std::endl;
  ofs.write( (char*) &nb_cameras, sizeof( uint32_t) );


  for ( uint32_t i = 0; i < nb_cameras; ++i )
  {
    double focal_length = camera_infos[i].focal_length;
    double kappa_1 = camera_infos[i].kappa_1;
    double kappa_2 = camera_infos[i].kappa_2;
    int32_t width =   camera_infos[i].width;
    int32_t height = camera_infos[i].height;
    double *rotation = new double[9];
    double *translation = new double[3];
    for ( int j = 0; j < 3; ++j )
    {
      for ( int k = 0; k < 3; ++k )
        rotation[3 * j + k] = camera_infos[i].rotation( j, k );
    }
    for ( int j = 0; j < 3; ++j )
      translation[j] = camera_infos[i].translation[j];
    ofs.write( (char *) &focal_length, sizeof( double ) );
    ofs.write( (char *) &kappa_1, sizeof( double ) );
    ofs.write( (char *) &kappa_2, sizeof( double ) );
    ofs.write( (char *) &width, sizeof( int32_t ) );
    ofs.write( (char *) &height, sizeof( int32_t ) );
    ofs.write( (char *) rotation, 9 * sizeof( double ) );
    ofs.write( (char *) translation, 3 * sizeof( double ) );
    delete [] rotation;
    delete [] translation;
  }

  std::cout << "write points " << std::endl;
  ofs.write( (char*) &nb_points, sizeof( uint32_t ) );

  // write out the points
  for ( uint32_t i = 0; i < nb_points; ++i )
  {
    // first the 3D position
    if (i % 1000000 == 0)
      std::cout << i << "/10000000" << std::endl;
    float *pos = new float[3];
    pos[0] = feature_infos[i].point.x;
    pos[1] = feature_infos[i].point.y;
    pos[2] = feature_infos[i].point.z;
    ofs.write( (char*) pos, 3 * sizeof( float ) );
    delete [] pos;

    // the number of cameras that point is visible in
    uint32_t nb_cams_visible_in = (uint32_t) feature_infos[i].view_list.size();
    ofs.write( (char*) &nb_cams_visible_in, sizeof( uint32_t ) );

    // for every camera: the keypoint data and the descriptor
    for ( uint32_t j = 0; j < nb_cams_visible_in; ++j )
    {
      uint32_t cam = feature_infos[i].view_list[j].camera;
      float x = feature_infos[i].view_list[j].x;
      float y = feature_infos[i].view_list[j].y;

      float scale = feature_infos[i].view_list[j].scale;
      float orientation = feature_infos[i].view_list[j].orientation;

      unsigned char *desc = new unsigned char[128];
      for ( uint32_t k = 0; k < 128; ++k )
        desc[k] = feature_infos[i].descriptors[128 * j + k];

      ofs.write( (char*) &cam, sizeof( uint32_t ) );
      ofs.write( (char*) &x, sizeof( float ) );
      ofs.write( (char*) &y, sizeof( float ) );
      ofs.write( (char*) &scale, sizeof( float ) );
      ofs.write( (char*) &orientation, sizeof( float ) );
      ofs.write( (char*) desc, 128 * sizeof( unsigned char ) );

      delete [] desc;
    }
  }

  ofs.close();
  std::cout << "--> done" << std::endl;

  return 0;
}




